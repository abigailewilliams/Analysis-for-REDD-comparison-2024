---
title: "Code for analysis 3 & 4"
output:
  html_document
---

# Setup

First we load the necessary packages and create the relevant paths.

```{r setup}

library(tidyverse)
library(reshape2)
library(sf)
library(ggspatial)
library(maps)
library(mapdata)
library(factoextra)
library(FactoMineR)
library(colorspace)
library(patchwork)

data_path<-'../data/analysis_3_4'
output_path<-'../outputs'
fig_path<-'../figures'
source_path <- '../scripts'

if(!dir.exists(fig_path))
  dir.create(fig_path)

if(!dir.exists(output_path))
  dir.create(output_path)

```

Next we read in the config file. This contains the VCS IDs and start years of the set of projects.

```{r config}

project_info <- data.frame(read.csv('../data/analysis_3_4/project_info.csv'))
projects <- project_info$project_no

```

We then tidy the raw data from the pipeline so that it is in an appropriate format for analysis.

```{r tidy_data}

# create directories for tidy data

tidy_data_path <-'../data/analysis_3_4/tidy_data'
tidy_data_historical_path <- '../data/analysis_3_4/tidy_data_historical'

if(!dir.exists(tidy_data_path))
  dir.create(tidy_data_path)

if(!dir.exists(tidy_data_historical_path))
  dir.create(tidy_data_historical_path)

source(file.path(source_path,'tidy_data.R'))

for(i in projects){
  
  if(!file.exists(paste0(tidy_data_path,'/',i,'.csv'))){
    
    tidy_data(project_no = i, base_path = data_path)
    
  }
  
}



```

We then create the relevant input paths and add them to the config file.

```{r project_paths}

# initialise vector

v <- c()

# path to tidy data

for(i in 1:length(projects)){
  path <- paste0(data_path,'/tidy_data/',projects[i],'.csv')
  v[i] <- path
}

project_info$path_to_tidy_data <- v

# path to historical data

for(i in 1:length(projects)){
  path <- paste0(data_path,'/tidy_data_historical/',projects[i],'.csv')
  v[i] <- path
}

project_info$path_to_tidy_data_historical <- v

```

Finally we read in the shapefiles and country data. Note that the country names correspond to those used by the map() function and may not be up to date.

```{r}

countries <- read.csv(file.path(data_path,'countries.csv'))
project_sf_combined <- read_sf(file.path(data_path,'project_combined.geojson'))
reference_sf_combined <- read_sf(file.path(data_path,'reference_combined.geojson'))

```


# Analysis 3

This analysis compares the self-selected reference areas with the matched counterfactuals generated by PACT. We start by subsetting to the 19 projects for which we have reference areas:

```{r subset_projects}

reference_area_projects <- c(944,958,1047,1094,1112,1113,1115,1118,1201,1329,1390,1392,1396,1399,1400,1566,1571,1650)
reference_area_dataset <- project_info %>% filter(project_no %in% reference_area_projects)

```

NB project 934 has been excluded here because we cannot generate CPCs for its historical reference period.

First we plot the locations of the project, reference area and PACT matched counterfactual for an exemplar project, VCS 944.

```{r exemplar_locations}

# extract input paths from config file

all_data <- read.csv(project_info$path_to_tidy_data[project_info$project_no == 944])

# read in project and reference area shapefiles

project_area <- read_sf(file.path(data_path,'project_combined.geojson')) %>% filter(ID==944)
reference_area <- read_sf(file.path(data_path,'reference_combined.geojson')) %>% filter(ID==944)

# get cf points from existing df

cf <- all_data %>% filter(type=='Counterfactual')
cf_points <- data.frame(lon=cf$lng,lat=cf$lat)

# get country outline

world <- fortify(map("worldHires", fill=TRUE, plot=FALSE))
map_data_peru <- world %>% filter(region=='Peru')

# making plot

map_plot <- ggplot(data=cf_points,aes(x=lon,y=lat))+
  geom_map(data=map_data_peru,map=map_data_peru,aes(x=long,y=lat,map_id=region),
           colour='black',fill='grey93',linewidth=1.2)+
  geom_point(aes(col='Counterfactual'),alpha=0.4,size=0.4)+
  geom_sf(data=reference_area,inherit.aes=FALSE,aes(fill='Reference'),colour=NA,alpha=0.7)+
  geom_sf(data=project_area,inherit.aes=FALSE,aes(fill='Project'),colour=NA,alpha=0.9)+
  scale_colour_manual(name='Legend',labels=c('Counterfactual'),values=c('blue'))+
  scale_fill_manual(name='Legend',labels=c('Project','Reference'),values=c('grey30','red'))+
  annotation_scale(text_cex = 1.25)+
  coord_sf()+
  theme_void()+
  theme(legend.title = element_blank(),
        legend.position='none')
 
map_plot

#ggsave(filename=file.path(fig_path,'fig_3_map_plot.png'),plot=map_plot,dpi=300,width=6,height=7)

```


We separately plot a zoomed-in view of the project shapefile.

```{r zoom_panel}

zoom_panel <- ggplot(data=cf_points,aes(x=lon,y=lat))+
  geom_point(aes(col='Counterfactual'),alpha=0.4,size=0.4)+
  geom_sf(data=reference_area,inherit.aes=FALSE,aes(fill='Reference'),colour=NA,alpha=0.7)+
  geom_sf(data=project_area,inherit.aes=FALSE,aes(fill='Project'),colour=NA,alpha=0.9)+
  scale_colour_manual(name='Legend',labels=c('Counterfactual'),values=c('blue'))+
  scale_fill_manual(name='Legend',labels=c('Project','Reference'),values=c('grey25','red'))+
  coord_sf(ylim=c(st_bbox(reference_area)$ymin,st_bbox(reference_area)$ymax),xlim=c(st_bbox(reference_area)$xmin,st_bbox(reference_area)$xmax))+
  theme_void()+
  theme(legend.title = element_blank(),
        text=element_text(size=14),
        legend.position='none',
        panel.background = element_rect(fill='grey93'),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=2.5))

zoom_panel
 
#ggsave(plot=zoom_panel,filename=file.path(fig_path,'fig_3_zoom_panel.png'),dpi=300,height=3,width=2)


```

Now we plot the comparison of the matching variables between our exemplar project, its self-selected reference area and the PACT matched counterfactual.

```{r compare_variables}

# select continuous variables

cont_data <- all_data %>% 
  dplyr::select(type,elevation,slope,access,starts_with('cpc'))

# convert deforestation proportions to percentages

cont_data[,5:length(cont_data)] <- 100*cont_data[,5:length(cont_data)]
cont_data_melt <- melt(cont_data)

# order variables for plot

cont_data_melt$variable <- factor(cont_data_melt$variable,levels=c('elevation','cpc0_u','cpc0_d',
                                                                   'slope','cpc5_u','cpc5_d',
                                                                   'access','cpc10_u','cpc10_d'))
# rename labels for plot

levels(cont_data_melt$variable) <- c('Elevation',
                                     'Forest~cover~t[0]',
                                     'Deforestation~t[0]',
                                     'Slope',
                                     'Forest~cover~t[-5]',
                                     'Deforestation~t[-5]',
                                     'Inaccessibility', 
                                     'Forest~cover~t[-10]',
                                     'Deforestation~t[-10]')

# set transparent colours for plotting

colours <- c('grey30','blue','red')
colours_alpha <- c(grDevices::adjustcolor(colours, alpha.f = 0.5))

# plotting the comparison

univariate_comp <- ggplot(data=cont_data_melt,mapping=aes(x=value,colour=type,linetype=type))+
  geom_density(adjust=10,linewidth=1.2)+
  facet_wrap(scales='free',nrow=3,~variable,labeller=label_parsed)+
  ylab('Density')+
  scale_colour_manual(values=colours_alpha,labels=c('Project','Counterfactual','Reference',guide='none'))+
  scale_linetype_manual(values=c(1,3,2))+
  scale_x_continuous(n.breaks=3,guide = guide_axis(check.overlap = TRUE))+
  theme_classic()+
  theme(text=element_text(size=16),
        legend.title=element_blank(),
        axis.title.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position='none')

univariate_comp

#ggsave(univariate_comp,filename=file.path(fig_path,'fig_3_univariate_comp.png'),width=5,height=5,dpi=300)



```

Here we calculate the mean values of the different variables for our exemplar project for reporting in the text.

```{r variable_values}

all_data %>% 
  select(type,elevation,slope,access,starts_with('cpc')) %>% 
  group_by(type) %>% 
  summarise_all(mean)


```

Still focusing on our exemplar project, we can compare the project, self-selected reference area and PACT matched counterfactual in multivariate space. In order to make a custom plot we extract the ellipses produced using the factoextra and FactoMineR packages and plot these manually using ggplot2.

```{r multivariate_comp}

# sampling an equal number of points across project, reference and counterfactual

min_samp_size <- all_data %>%
  group_by(type) %>%
  count() %>% 
  ungroup() %>%
  select(n) %>%
  min()

data <- all_data %>%
  group_by(type) %>%
  sample_n(min_samp_size) %>%
  ungroup()

# storing the type vector before removing it

type <- data$type

# removing inappropriate variables for PCA (index, type, pair ID, latitude, longitude, land use class)
# 
# data_for_pca <- data %>% 
#   select(-c(X,type,pair,lat,lng,starts_with('luc'))) %>% 
#   data.frame()

data_for_pca <- data %>% 
  select(elevation,slope,access,starts_with('cpc')) %>% 
  data.frame()

# run pca

pca <- PCA(data_for_pca,graph=F,scale.unit = T,ncp=2)

# extract 95% confidence ellipses

plot_data <- fviz_pca_ind(pca,col.ind = type,geom='point',alpha.ind=0.5,addEllipses = T)
ellipses <- ggplot_build(plot_data)$data[[2]]

# convert ellipses to polygons

pca_polys_df <- st_as_sf(ellipses[,3:5],coords=c('x','y'))
pca_polys <- st_sf(aggregate(pca_polys_df$geometry, list(pca_polys_df$group),
                             function(g){
                               st_cast(st_combine(g),'POLYGON')
                             }))
colnames(pca_polys)[1] <- 'type'

# renaming groups according to identity

pca_polys[1,1] <- 'Counterfactual'
pca_polys[2,1] <- 'Project'
pca_polys[3,1] <- 'Reference'

# getting pca points and prop variances

pca_points <- plot_data$data
pc1_propvar <- round(pca$eig[1,2],digits=1)
pc2_propvar <- round(pca$eig[2,2],digits=1)

# plot custom plot

pca_plot <- pca_polys %>% 
  mutate(order = c(2,3,1)) %>% 
  arrange(order) %>% 
  ggplot()+
  geom_sf(mapping=aes(colour=type,linetype=type),fill=NA,alpha=0.5,linewidth=1.5)+
  scale_colour_manual(name='Legend',
                      breaks=c('Project','Counterfactual','Reference'),
                      values=colours_alpha)+
  scale_linetype_manual(values=c(3,1,2))+
  xlab(paste0('PC1 - ',pc1_propvar,'%'))+
  ylab(paste0('PC2 - ',pc2_propvar,'%'))+
  theme_classic()+
  theme(text=element_text(size=16),
        legend.title=element_blank(),
        legend.position='none')

pca_plot

#ggsave(filename=file.path(fig_path,'fig_3_pca_plot.png'),plot=pca_plot,dpi=300,width=3.5,height=2)


```

Now we generate the standardised mean differences across all projects. For the reference-project differences we match points based on the minimum Mahalanobis distance and extract the stanardised mean difference. For the counterfactual-project matches, the matching has already been carried out as part of the PACT method, and is stored in the structure of the data. 

This step is time-consuming to run, so the results are provided in the directory /data. Should you wish to run it yourself the code is also provided below.

```{r smd}

if(file.exists(file.path(data_path,'std_mean_diff.csv'))) {

  std_mean_diff_df <- read.csv(file.path(data_path,'std_mean_diff.csv'))

} else {

  std_mean_diff_df <- data.frame(matrix(nrow=0,ncol=4))
  colnames(std_mean_diff_df) <- c('variable','smd','type','project_no')
  
  source(file.path(source_path,'std_mean_diff.R'))
  
  for(p in 1:length(reference_area_projects)) {
    
    if(file.exists(reference_area_dataset$path_to_tidy_data[p])){
      
      all_data <- read.csv(reference_area_dataset$path_to_tidy_data[p])
      project_no <- reference_area_dataset$project_no[p]
      
      df <- std_mean_diff(all_data,project_no)
      
      std_mean_diff_df <- rbind(std_mean_diff_df,df)
      
    }
    
  }
    
  # reversing sign for interpretability (differences are relative to the project)
    
  std_mean_diff_df$smd <- (-1)*std_mean_diff_df$smd
  
  write.csv(std_mean_diff_df,file.path(data_path,'std_mean_diff.csv'),row.names=F)

}

```


```{r plot_smd}
# changing level order

std_mean_diff_df$variable <- factor(std_mean_diff_df$variable,levels= c('cpc10_d','cpc5_d','cpc0_d',
                'cpc10_u','cpc5_u','cpc0_u',
                'access','slope','elevation'))

# plotting

std_mean_diff_plot <- ggplot(std_mean_diff_df,aes(x=smd,y=variable,colour=type))+
  geom_boxplot(outlier.shape=NA)+
  geom_point(alpha=0.3,position=position_jitterdodge(dodge.width=0.75,jitter.width=0.3))+
  geom_vline(xintercept=0)+
  geom_vline(xintercept=0.25,lty=2,colour='grey40')+
  geom_vline(xintercept=-0.25,lty=2,colour='grey40')+
  scale_colour_manual(breaks=c('Reference','Counterfactual'),values=c('red','blue'))+
  scale_y_discrete(labels=c(bquote(Deforestation~t[-10]~("%")),
                            bquote(Deforestation~t[-5]~("%")),
                            bquote(Deforestation~t[0]~("%")),
                            bquote(Forest~cover~t[-10]~("%")),
                            bquote(Forest~cover~t[-5]~("%")),
                            bquote(Forest~cover~t[0]~("%")),
                            'Inaccessibility (mins)',paste0('Slope (',intToUtf8(176),')'),'Elevation (m)'))+
  xlab('Standardised mean difference')+
  xlim(-8,7)+
  #geom_text(label=project_no)+
  theme_classic()+
  theme(axis.title.y=element_blank(),
        legend.title=element_blank(),
        legend.box.background=element_rect(),
        legend.position='none',
        text=element_text(size=16),
        axis.text.y=element_text(size=16))

std_mean_diff_plot

ggsave(filename=file.path(fig_path,'fig_3_std_mean_diff_plot.png'),plot=std_mean_diff_plot,dpi=300,width=6,height=4)

```


From the standardised mean differences we can also extract figures for our exemplar project (VCS 944) to report in the text.

```{r SMD_values}


filter(std_mean_diff_df, project_no == 944)


```

Finally, looking across all projects, we can calculate the similarities in multivariate space between project, reference and counterfactual for each project. As explained in the methods, this is calculated as the average of the the similarity (overlap) and (1-dissimilarity (distance)).

```{r multivariate_similarity}

pca_sims <- data.frame(matrix(nrow=0,ncol=9))
colnames(pca_sims) <- c('project','ref_overlap','cf_overlap',
                        'ref_distance','cf_distance',
                        '1-ref_distance','1-cf_distance',
                        'avg_ref','avg_cf')

source(file.path(source_path,'pca_overlap.R'))

for(p in 1:length(reference_area_projects)){
  
  if(file.exists(reference_area_dataset$path_to_tidy_data[p])){
  
  # define params
  
  all_data <- read.csv(reference_area_dataset$path_to_tidy_data[p])
  project_no <- reference_area_dataset$project_no[p]
  
  # run plotting function
  
  df <- pca_overlap(all_data,project_no)
  
  # add to df
  
  pca_sims <- rbind(pca_sims,df)
  
  }
  
}

# plotting the distribution of similarities:

pca_overlap_plot <- pca_sims %>% select(avg_ref,avg_cf) %>% 
  melt() %>% 
  ggplot(aes(x=value,fill=variable))+
  geom_density(colour=NA,alpha=0.7,adjust=3)+
  theme_classic()+
  xlab('Similarity to project')+
  ylab('Density')+
  scale_fill_manual(labels=c('Reference','Counterfactual'),values=c('red','blue'))+
  xlim(0.05,1)+
  theme(legend.title=element_blank(),
        legend.position = 'none',
        text=element_text(size=16))


pca_overlap_plot

ggsave(pca_overlap_plot,filename=file.path(fig_path,'/fig_3_pca_overlap.png'),width=5,height=4,dpi=300)



```

Extracting the mean similarities:

```{r mean_sims}

pca_sims %>% select(avg_ref, avg_cf) %>% summarise_all(mean)

```

NB figure 3 was produced by aligning all panels together and adding annotations in figure editing software.

Maps were also produced for figures in the supplementary information, using the code below, which was customised according to the needs of individual projects (e.g. adding zoom panels, adjusting the layout manually).

```{r summary_fig}

source(file.path(source_path,'summary_fig.R'))

for(p in 1:length(reference_area_projects)){
  
  if(file.exists(reference_area_dataset$path_to_tidy_data[p])){
    
  ######################
    
  p <- 5
  
  ######################
    
  project_no <- reference_area_dataset$project_no[p]
  country <- countries$country[p]
  all_data <- read.csv(reference_area_dataset$path_to_tidy_data[p])
  project_sf <- project_sf_combined %>% filter(ID==project_no)
  ref_sf <- reference_sf_combined %>% filter(ID==project_no)
  
  make_summary_fig(all_data=all_data,
                   project_sf=project_sf,
                   ref_sf=ref_sf,
                   output_path=fig_path,
                   country=country,
                   project_no=project_no)
  
  # additionally create zoom panel, if desired
  
  # make_zoom_panel(all_data=all_data,
  #                  project_sf=project_sf,
  #                  ref_sf=ref_sf,
  #                  output_path=fig_path,
  #                  country=country,
  #                  project_no=project_no)
    
  }
  
}


```
 

```{r}

library(factoextra)
library(FactoMineR)

min_samp_size <- all_data %>%
  group_by(type) %>%
  count() %>%
  ungroup() %>%
  select(n) %>%
  min()

# process data for pca

data <- all_data %>%
  group_by(type) %>%
  sample_n(min_samp_size) %>%
  ungroup()

type <- data$type

data_for_pca <- data %>%
  select(-c(X,type,pair,lat,lng,starts_with('luc'))) %>%
  data.frame()

# run pca and get ellipse data

pca <- PCA(data_for_pca,graph=F,scale.unit = T,ncp=2)

plot_data <- fviz_pca_ind(pca,col.ind = type,geom='point',alpha.ind=0.5,addEllipses = T)

# get ellipses

ellipses <- ggplot_build(plot_data)$data[[2]]

# converting to polygons

pca_polys_df <- st_as_sf(ellipses[,3:5],coords=c('x','y'))
pca_polys <- st_sf(aggregate(pca_polys_df$geometry, list(pca_polys_df$group),
                             function(g){
                               st_cast(st_combine(g),'POLYGON')
                             }))
colnames(pca_polys)[1] <- 'type'

# renaming groups according to identity

pca_polys[1,1] <- 'Counterfactual'
pca_polys[2,1] <- 'Project'
pca_polys[3,1] <- 'Reference'


pc1_propvar <- round(pca$eig[1,2],digits=1)
pc2_propvar <- round(pca$eig[2,2],digits=1)

# plot custom plot

pca_polys %>% 
  mutate(order = c(2,3,1)) %>% 
  arrange(order) %>% 
  ggplot()+
  geom_sf(mapping=aes(colour=type),fill=NA,linewidth=1.5)+
  scale_colour_manual(name='Legend',
                      breaks=c('Project','Reference','Counterfactual'),
                      values=c('grey30','red','blue'))+
  scale_fill_manual(name='Legend',
                    breaks=c('Project','Reference','Counterfactual'),
                    values=c('grey30','red','blue'))+
  xlab(paste0('PC1 - ',pc1_propvar,'%'))+
  ylab(paste0('PC2 - ',pc2_propvar,'%'))+
  theme_classic()+
  theme(text=element_text(size=18),
        legend.title=element_blank(),
        #legend.box.background=element_rect(),
        legend.position = 'none')

```




# Analysis 4

We start by reading in the data on the self-reported deforestation rate in both the project and the baseline scenario. These data were extracted from project design documents and project monitoring documents. They are given here as rates in hectares per year. The method for calculating the evaluation period and annual rate is detailed in S6.

We have 22 projects at this stage, i.e. the number of projects for which we were able to find information on the baseline deforestation rate in hectares per year.

```{r get_data}

self_report_ha <- read.csv(file.path(data_path,'self_reported_deforestation_compound.csv')) %>%
  mutate(
    bsl_def = as.numeric(bsl_def),
    proj_def = as.numeric(proj_def)
  )

self_report_ha

```


```{r get_project_ids}

analysis_4_projects <- self_report_ha %>% 
  select(project_no) %>%
  pull() %>%
  as.vector() %>% 
  unique()

```

We then collate data on the project areas (based on their shapefiles) and the proportion of undisturbed forest at t0. This allows us to calculate the self-reported deforestation rate relative to the amount of forest present at the beginning of the project, such that it is comparable to the PACT estimates calculated later.

Extracting areas from shapefiles:

```{r extract_areas}

pa_areas <- data.frame(matrix(ncol=2,nrow=length(analysis_4_projects)))
colnames(pa_areas) <- c('project_no','pa_area_ha')

for(p in 1:length(analysis_4_projects)){
  
  project_no <- analysis_4_projects[p]
  
  project_shapefile <- project_sf_combined %>% filter(ID == project_no)
  
  validity_check <- (st_is_valid(project_shapefile))
  
  if(all(validity_check)==T){
  
  pa_area_ha <- sum(st_area(project_shapefile))/10000 # convert to ha
  
  } else {
    
  pa_area_ha <- NA
  
  }
    
  
  pa_areas[p,2] <- pa_area_ha
  pa_areas[p,1] <- project_no
  
}


```

Extracting proportion of forest at t0:

```{r extract_prop_und}

# prop_und <- data.frame(matrix(nrow=nrow(self_report_ha),ncol=2))
# colnames(prop_und) <- c('project_no','prop_und_proj')
# 
# for(p in 1:length(analysis_4_projects)){
# 
#   # define params
#   
#   project_no <- analysis_4_projects[p]
#   all_data <- read.csv(project_info$path_to_tidy_data[project_info$project_no == project_no])
#   t0 <- project_info$start_year[project_info$project_no == project_no]
#   
#   # get proportion of 1s at t0
#   
#   t0_index <- grep(paste0('luc_',t0),colnames(all_data))
#   data_filtered <- all_data[all_data[,t0_index]==1,]
#   
#   proj_total <- all_data %>% filter(type=='Project') %>% nrow()
#   proj_1s <- data_filtered %>% filter(type=='Project') %>% nrow()
#   prop_proj <- proj_1s/proj_total
#   
#   prop_und[p,1] <- project_no
#   prop_und[p,2] <- prop_proj
# 
# }



```


########## NEW BIT: COMPOUND DEFORESTATION #########


Extracting project start years, and taking project end year to be 2021:

```{r}

# years <- project_info %>% 
#   filter(project_no %in% pa_areas$project_no) %>% 
#   select(start_year) %>% 
#   pull() %>% 
#   as.vector()
# 
# projects_years <- data.frame(project_no = analysis_4_projects,
#                              start_year = years, 
#                              end_year = 2021)
# 
# # projects_years <- projects_years %>% 
# #   mutate(period_length = end_year - start_year)
# 
# projects_years

```

Expanding the df

```{r}

# expanded_df <- projects_years %>%
#   select(project_no, start_year, end_year) %>%
#   rowwise() %>%
#   mutate(year = list(start_year:end_year)) %>%
#   unnest(year) %>%
#   select(project_no, year)
# 
# expanded_df

```

We now need to add another column with the % forest at tx.


```{r}

# copy expanded df and add new column for proportion of undisturbed forest

if(file.exists(file.path(data_path,'proportion_undisturbed_compound.csv'))) {
  
  prop_und_compound <- read.csv(file.path(data_path,'proportion_undisturbed_compound.csv'))
                                
  } else {

  prop_und_compound <- expanded_df
  prop_und_compound$prop_und <- NA
  
  for(r in 1:nrow(prop_und_compound)){
  
    # define params
    
    project_no <- prop_und_compound[[r,1]]
    year <- prop_und_compound[[r,2]]
    
    # get data
    
    all_data <- read.csv(project_info$path_to_tidy_data[project_info$project_no == project_no])
    
    # extract column for relevant year
  
    year_index <- grep(paste0('luc_',year),colnames(all_data))
    data_filtered <- all_data[all_data[,year_index]==1,]
    
    # calculate proportion of forest at given year
    
    proj_total <- all_data %>% filter(type=='Project') %>% nrow()
    proj_1s <- data_filtered %>% filter(type=='Project') %>% nrow()
    prop_proj <- proj_1s/proj_total
    
    # add result to df
  
    prop_und_compound[r,3] <- prop_proj
  
    }
    
  write.csv(prop_und_compound, file='../data/analysis_3_4/proportion_undisturbed_compound.csv',row.names=F)

  }

prop_und_compound

```

Compiling these data sources and calculating the self-reported rate as an annual percentage of the undisturbed forest at the project start:


```{r self_report_rate}

# calculating denominators by which to divide the self reported rates: (denominator = 4c area * prop forested at t0)

denominators <- prop_und_compound %>% 
  inner_join(pa_areas,by='project_no') %>% 
  mutate(denominator = prop_und*pa_area_ha)

# calculating self-reported deforestation rates as percentages

self_report_percent <- denominators %>% 
  #filter(project_no %in% analysis_4_projects) %>% 
  left_join(self_report_ha) %>% 
  mutate(self_bsl_percent = 100*(bsl_def / denominator), 
         self_proj_percent = 100*(proj_def / denominator))

self_report_percent

```

For the subset of projects for which we have data on the self-reported deforestation rates, we calculate the deforestation rates using the PACT method for both project and counterfactual, across all projects.

The inputs for this are the project datasets (as before) and the JRC evaluation periods. As explained in S6, the updating of JRC data in December of every year means that the JRC evaluation period must be adjusted to align optimally with the self-reported evaluation period. The method for doing this is detailed in S6.

```{r PACT_def}

# read in JRC evaluation periods

jrc_eval_periods <- read.csv(file.path(data_path,'jrc_evaluation_periods.csv')) %>% 
  filter(project_no %in% analysis_4_projects) %>% 
  select(-jrc_period_length) %>%
  mutate(year = list(start_year_for_JRC:end_year_for_JRC)) %>%
  unnest(year) %>%
  select(project_no, year)

# initialise df

pact_def_rates <- jrc_eval_periods %>% 
  mutate(
    pact_proj = NA,
    pact_cf = NA)

source(file.path(source_path,'pact_deforestation.R'))

for(p in 1:nrow(pact_def_rates)){
  
  # define params
  
  project_no <- pact_def_rates[p,1]
  t0 <- pact_def_rates[p,2]
  tend <- t0+1
  all_data <- read.csv(paste0(data_path,'/tidy_data/',project_no,'.csv'))
  proj_data <- all_data %>% filter(type=='Project')
  cf_data <- all_data %>% filter(type=='Counterfactual')
  
  # get deforestation rate values
  
  proj_rate <- calculate_def_rate(project_no,t0,tend,proj_data)
  cf_rate <- calculate_def_rate(project_no,t0,tend,cf_data)
  
  #bind to existing df
  
  pact_def_rates$pact_proj[p] <- proj_rate
  pact_def_rates$pact_cf[p] <- cf_rate
  
}

```
We now average the PACT and self-reported rates across the years, obtaining two values for each project (project and baseline) in each case.

```{r}

avg_compound_pact_rates <- pact_def_rates %>%
  group_by(project_no) %>%
  dplyr::summarize(
    pact_proj = mean(pact_proj, na.rm = TRUE),
    pact_cf = mean(pact_cf, na.rm = TRUE)
  )

avg_compound_selfreport_rates <- self_report_percent %>%
  group_by(project_no) %>%
  dplyr::summarize(
    self_proj = mean(self_proj_percent, na.rm = TRUE),
    self_bsl = mean(self_bsl_percent, na.rm = TRUE)
  )

```

We can now combine the self-reported data with the PACT data. **We have 22 projects in total at this stage.**

```{r combined_selfreport_PACT}

def_rates <- avg_compound_selfreport_rates %>% 
  select(project_no, self_proj, self_bsl) %>% 
  mutate(pact_cf = avg_compound_pact_rates$pact_proj,
              pact_proj = avg_compound_pact_rates$pact_cf)

def_rates

```

It is also necessary to calculate the historic deforestation rate in the reference area. This is assessed in the self-reported reference area during the self-reported historical evaluation period, but using the PACT method. It is only possible to calculate this for projects with reference areas available (n=16).

```{r historic_rate}
# read in self-reported historical period dates

ref_periods <- read.csv(file.path(data_path,'historical_reference_periods.csv'))

# expand df

ref_hist_rates <- ref_periods %>% 
  rowwise() %>%
  mutate(year = list(start:end)) %>%
  unnest(year) %>%
  rename(project_no = project) %>% 
  select(project_no, year) %>% 
  mutate(rate = NA)

source(file.path(source_path,'pact_deforestation.R'))

for(p in 1:nrow(ref_hist_rates)){
    
    # define params
    
    project_no <- ref_hist_rates$project_no[p]
    reference_data <- read.csv(paste0('../data/analysis_3_4/tidy_data/',project_no,'.csv')) %>% 
      filter(type == 'Reference')
    t0 <- ref_hist_rates$year[p]
    tend <- t0+1
    
    # get deforestation rate values
    
    rate <- calculate_def_rate(data=reference_data,
                               project_no=project_no,
                               t0=t0,
                               tend=tend)
    
    #bind to existing df
    
    ref_hist_rates[p,3] <- rate

}

head(ref_hist_rates)

```

Now to filter, average and combine all the data:

```{r wrangle_historic_data}

# filter out unwanted projects

ref_hist_rates_filtered <- ref_hist_rates %>% filter(project_no != 1118)  # VCS 1118 is excluded due to being a negative creditor

# average rates across projects

avg_compound_ref_hist <- ref_hist_rates_filtered %>%
  group_by(project_no) %>%
  dplyr::summarize(ref_hist = mean(rate, na.rm = TRUE))

# compile data sources for projects with reference areas

def_rates_all <- def_rates %>%
  filter(project_no %in% avg_compound_ref_hist$project_no) %>%
  mutate(ref_hist = avg_compound_ref_hist$ref_hist)

def_rates_all


```


Here we filter out overcrediting projects are filtered out based on the PACT-specific results from analysis 1. Projects with an adjusted additionality of < 1 (i.e. PACT additionality < self-reported additionality) are overcreditors. 

Project VCS 1571 is also manually excluded here. We lack a PACT estimate for this project due to non-convergence of the pixel-matching algorithm. However, the self-reported baseline for this project is far lower than the PACT counterfactual (there is also a smaller difference in terms of deforestation in the project in the direction of overcrediting. Overall, this clearly indicates that project 1571 is an undercreditor and so should be excluded from our analysis.

```{r exclude_undercreditors}

# read in additonality data

avd_def <- read.csv(file.path(data_path,'CF_VCS_avoided_deforestation.csv'))

# make list of undercrediting projects to exclude from our datasets

undercredit_list <- avd_def %>%
  filter(cf_source == 'PACTv2' & Aadj > 1 ) %>%
  pull(ID) %>%
  as.vector()

# exclude undercreditors from total set

def_rates_overcred <- def_rates %>% 
  filter(! project_no %in% undercredit_list)

# repeat for reference area set

def_rates_reference_overcred <- avg_compound_ref_hist %>% 
  filter(! project_no %in% undercredit_list) %>% 
  inner_join(def_rates, by='project_no')

# manually removing 1571

def_rates_overcred <- def_rates_overcred %>% 
  filter(project_no != 1571)

def_rates_reference_overcred <- def_rates_reference_overcred %>% 
  filter(project_no != 1571)

# print both datasets

print(def_rates_overcred)

print(def_rates_reference_overcred)


```

After filtering for overcreditors, we have 15 projects total, 11 of which have PACT-assessed historical deforestation rates from their reference areas.


We can now plot the distributions of deforestation rates for both counterfactuals (PACT matched, PACT-assessed in historical reference period, self-reported baselines) and project (PACT-assessed vs self-reported):

```{r fig_4_a}

panel_a_melt <- def_rates_overcred %>%
  melt(id.vars='project_no')

panel_a_ref_melt <- def_rates_reference_overcred %>% 
  select(project_no,ref_hist) %>% 
  melt(id.vars='project_no')

panel_a_df <- bind_rows(panel_a_melt,panel_a_ref_melt) %>% 
  na.omit()

panel_a_summary <- panel_a_df %>%
  select(variable,value) %>%
  group_by(variable) %>%
  summarise(median=median(value),
            lq = quantile(value, 0.25),
            uq = quantile(value,0.75))

# plotting

cols_list <- c("#2171B5","#2171B5","#2171B5",'grey30','grey30')

panel_a <- panel_a_df %>% 
  mutate(variable=factor(variable,levels=c('pact_cf','ref_hist','self_bsl','pact_proj','self_proj'))) %>%
  ggplot(aes(x=variable,y=value,fill=variable))+
  geom_rect(aes(xmin=0.5, xmax=3.5, ymin=-Inf, ymax=Inf), fill=alpha("#DEEBF7", 0.9)) +
  geom_rect(aes(xmin=3.5, xmax=5.5, ymin=-Inf, ymax=Inf), fill="grey90") +
  geom_point(position=position_jitter(width=0.25),alpha=0.2,size=4,aes(colour=variable),shape=16)+
  stat_summary(fun=median,geom='crossbar',width=0.2,aes(colour=variable))+
  geom_errorbar(data=panel_a_summary,aes(x=variable,colour=variable,ymin=lq, ymax=uq),width=0.2,inherit.aes=F)+
  stat_summary(fun=median,geom='crossbar',width=0.2,aes(colour=variable))+
  scale_fill_manual(values=cols_list)+
  scale_colour_manual(values=cols_list)+
  scale_x_discrete(labels=c(' ACC \n \n Matched \n \n 15',
                            ' ACC \n \n Expert-defined \n \n 11',
                            'Certified \n \n Expert-defined \n \n 15 ',
                            ' ACC \n \n Project \n \n 11',
                            'Certified \n \n Project \n \n 11'))+
  ylab('Deforestation rate (%/year)')+
  annotate(geom='text',x=1.9,y=5,label='Counterfactual',size=20/.pt,colour="#2171B5")+
  annotate(geom='text',x=4.5,y=5,label='Project',size=20/.pt,colour='grey30')+
  theme_classic()+
  theme(axis.title.x = element_blank(),
        legend.position = 'none',
        text = element_text(size=18),
        axis.text.x=element_text(size=13),
        axis.text.y=element_text(size=18))

panel_a

```


Now we can plot the distribition of pairwise differences between counterfactual and project deforestation rates, for each project.

```{r fig_4_b}

# calculating the pairwise differences

panel_b_summary <- def_rates_overcred %>%
  mutate(bsl_diff = self_bsl - pact_cf,
         proj_diff = pact_proj - self_proj,
         sum = bsl_diff + proj_diff) %>% 
  select(project_no,bsl_diff,proj_diff,sum) %>% 
  melt(id.vars='project_no') %>% 
  mutate(variable=factor(variable,levels=c('bsl_diff','proj_diff','sum'))) %>% 
  select(variable,value) %>% 
  group_by(variable) %>% 
  summarise(median=median(value),
            lq = quantile(value, 0.25),
            uq = quantile(value,0.75))

# plotting

panel_b <- def_rates_overcred %>% 
  mutate(bsl_diff = self_bsl - pact_cf,
         proj_diff = pact_proj - self_proj,
         sum = bsl_diff + proj_diff) %>% 
  select(project_no,bsl_diff,proj_diff,sum) %>% 
  melt(id.vars = 'project_no') %>% 
  ggplot(aes(x=variable,y=value,fill=variable)) +
  #geom_rect(aes(xmin=0.5, xmax=1.5, ymin=-Inf, ymax=Inf), fill=alpha("#DEEBF7", 0.9)) +
  #geom_rect(aes(xmin=1.5, xmax=2.5, ymin=-Inf, ymax=Inf), fill="grey90") +
  #geom_rect(aes(xmin=2.5, xmax=3.5, ymin=-Inf, ymax=Inf), fill="#edf8e9") +
  geom_hline(yintercept=0,lty=2,colour='grey30')+
  geom_point(position=position_jitter(width=0.25),alpha=0.2,size=4,aes(colour=variable),shape=16)+
  stat_summary(fun=median,geom='crossbar',width=0.2,aes(colour=variable))+
  geom_errorbar(data=panel_b_summary,aes(x=variable,colour=variable,ymin=lq, ymax=uq),width=0.2,inherit.aes=F)+
  scale_fill_manual(values=c("#2171B5",'grey30',"#F15412"))+
  scale_colour_manual(values=c("#2171B5",'grey30',"#F15412"))+
  scale_x_discrete(labels=c('Counterfactual','Project','Combined'))+
  annotate(geom='text',x=3.7,y=0.8,label='Overcrediting',angle=90,size=18/.pt,colour='grey30')+
  #annotate(geom='text',x=3.7,y=-1.5,label='Undercrediting',angle=90,size=18/.pt,colour='grey50')+
  ylab('Difference in deforestation rate (%/year)')+
  coord_cartesian(xlim=c(1,3.3))+
  theme_classic()+
  theme(axis.title.x = element_blank(),
        legend.position = 'none',
        text=element_text(size=18),
        axis.text.x=element_text(size=16),
        axis.text.y=element_text(size=18))

panel_b

```


Finally, we can plot the contribution of counterfactual and project effects to the overall error.

```{r fig_4_c}

def_rates_overcred_withdiff <- def_rates_overcred %>% 
  mutate(bsl_diff = self_bsl - pact_cf,
         proj_diff = pact_proj - self_proj,
         sum = bsl_diff + proj_diff)

# ordering by sum of differences

order <- def_rates_overcred_withdiff %>%
  select(project_no,bsl_diff,proj_diff) %>% 
  rowwise() %>%
  mutate(sum=sum(c_across(contains('diff')))) %>%
  ungroup() %>%
  arrange(sum) %>%
  pull(project_no) %>%
  as.vector()

def_rates_overcred_withdiff$project_no <- factor(def_rates_overcred_withdiff$project_no,levels=order)

# plotting

panel_c <- def_rates_overcred_withdiff %>% 
  select(project_no,bsl_diff,proj_diff) %>%
  melt(id.vars='project_no') %>% 
  ggplot(aes(x=project_no,y=value,fill=variable))+
  geom_bar(position='stack', stat='identity',width=0.7,alpha=0.5)+
  theme_classic()+
  scale_fill_manual(breaks=c('bsl_diff','proj_diff'),
                    labels=c('Counterfactual','Project'),values=c("#2171B5",'grey30'))+
  scale_x_discrete(guide = guide_axis(angle = 90))+
  ylab('Difference in deforestation rate (%/year)')+
  xlab('Project ID')+
  geom_hline(yintercept=0,lty=2,col='grey30')+
  annotate(geom='text',x=16.5,y=2,label='Overcrediting',angle=90,size=18/.pt,colour='grey30')+
  #annotate(geom='text',x=18.5,y=-1.5,label='Undercrediting',angle=90,size=18/.pt,colour='grey50')+
  coord_cartesian(xlim=c(1,18))+
  theme(legend.title=element_blank(),
        axis.text.x=element_text(size=18),
        legend.position=c(0.20,0.8),
        #legend.background = element_rect(colour='grey30'),
        text=element_text(size=18),
        legend.text = element_text(size=16),
        axis.text.y=element_text(size=18))

panel_c


```

This can be compiled into a single figure. Note that the annotations were added using figure editing software.

```{r fig_4}

fig_4 <- (panel_a | panel_b) / plot_spacer() / panel_c +
  plot_layout(heights=c(5.9,0.2,5.9))+
  plot_annotation(tag_levels='a') &
  theme(plot.tag = element_text(face='bold'))

ggsave(fig_4,filename=file.path(fig_path,'fig_4.png'),dpi=300,width=12,height=12)

```

See below for stats that were reported in the text.

```{r}

def_rates_overcred %>% select(-project_no) %>% summarise_all(median)


```

Median pairwise differences: for this I calculated the counterfactual difference as (self-reported reference - PACT counterfactual) and the project difference as (PACT project - self-reported project). I then summed these differences. The resulting df is printed below.

```{r}

def_rates_overcred_diff <- def_rates_overcred %>% 
  mutate(bsl_diff = self_bsl - pact_cf,
         proj_diff = pact_proj - self_proj,
         sum = bsl_diff + proj_diff)

print(def_rates_overcred_diff)

```

```{r}

def_rates_overcred_diff %>% select(-project_no) %>% summarise_all(median)

```

Median pairwise differences for reference area data: here I calculate the PACT counterfactual-PACT reference difference as (PACT reference - PACT counterfactual) and the Self-reported reference-PACT reference difference as (Self-reported - PACT reference). The resulting df and medians are shown below.

```{r}

def_rates_reference_overcred_diff <- def_rates_reference_overcred %>% 
  mutate(cf_hist_diff = ref_hist - pact_cf,
         hist_self_diff = self_bsl - ref_hist)

print(def_rates_reference_overcred)

```

```{r}

def_rates_reference_overcred_diff %>% select(cf_hist_diff,hist_self_diff) %>% summarise_all(median)

```

Statistics below for reporting in the text.

***Paired wilcox test: PACT counterfactual vs. PACT reference historical***

This test involves reference area historic data so n=11.

```{r}

wilcox.test(def_rates_reference_overcred$pact_cf, def_rates_reference_overcred$ref_hist, paired=T)

```

***Paired wilcox test: PACT reference historical vs. self-reported reference***

This test involves reference area historic data so n=11.

```{r}

wilcox.test(def_rates_reference_overcred$ref_hist, def_rates_reference_overcred$self_bsl, paired=T)

```

***Paired wilcox test: PACT counterfactual vs self-reported reference***

n=15.

```{r}

wilcox.test(def_rates_overcred$pact_cf, def_rates_overcred$self_bsl, paired=T)

```

***Paired wilcox test: PACT project vs. self-reported project***

n=15.

```{r}

wilcox.test(def_rates_overcred$pact_proj, def_rates_overcred$self_proj, paired=T)

```

***One-sample wilcox test: combined difference***

n=15.

Using the df containing the paired differences and the sums of these.

```{r}


wilcox.test(def_rates_overcred_diff$sum)


```
 


